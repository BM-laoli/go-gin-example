> è¿™ä¸ªåˆ†æ”¯ä¸‹ï¼Œæˆ‘ä»¬ä¼šåœ¨ä¸»çº¿ä¸Šå’Œç…é±¼å¤§ç¥çš„go-grpcä¿æŒä¸€è‡´ï¼Œç„¶åä¼šæ–°å¼€ä¸€äº› å°åº—ï¼Œå‚ç…§æœ€æ–°çš„æ–‡æ¡£å’Œåº“(2023.1.12)æ¥åšè¡¥å……è¯´æ˜å’Œè®°å½•ğŸ“ï¼Œå…·ä½“çš„å†…å®¹ï¼Œå’Œç»†ææœ«èŠ‚ï¼Œè¿™é‡Œä¸ä¼šè¿‡å¤šå±•å¼€ï¼Œç…é±¼çš„blog è¯´çš„ä¹Ÿæ¯”è¾ƒçš„å®Œå–„äº†ã€‚

# ç¯å¢ƒè¯´æ˜(æ ¡å‡†æ–‡æ¡£1)

> é¦–å…ˆæ˜¯å®‰è£…ï¼Œprotobuf çš„è¿‡ç¨‹å’Œé…ç½® æœ¬åœ°å¼€å‘ç¯å¢ƒå˜é‡

1. å®‰è£…

æˆ‘æ˜¯macç”µè„‘ï¼Œç›´æ¥å®‰è£…å°±å¥½å•¦

```shell
$ brew install protobuf 
# å¦‚æœæ‚¨é‡è§äº†ä¸€äº› å®‰è£…çš„æŠ¥é”™ï¼Œæ¯”å¦‚å®‰äº†ä¸€èˆ¬ï¼Œè¿˜å‰©ä¸€åŠï¼Œè¿™ä¸ªæ—¶å€™ï¼Œè¯·æœ‰å¯èƒ½æ‰¾ä¸åˆ°å¯¹åº”çš„tackidçš„æ–‡ä»¶ï¼Œä½ éœ€è¦æ¸…ç†ä¸€ä¸‹
# brew çš„ç¼“å†² ç„¶åå†é‡æ–° brew install 

Warning: Bottle missing, falling back to the default domain...
==> Downloading https://ghcr.io/v2/homebrew/core/protobuf/manifests/3.17.3
Already downloaded: /Users/administrator/Library/Caches/Homebrew/downloads/6d20d704ec9f8c1fe7646d23a2e0e96e28c081140c98ef75911b36eae4e91f6f--protobuf-3.17.3.bottle_manifest.json
==> Downloading https://ghcr.io/v2/homebrew/core/protobuf/blobs/sha256:ef7a56961
==> Downloading from https://pkg-containers.githubusercontent.com/ghcr1/blobs/sh
######################################################################## 100.0%
==> Installing dependencies for protobuf: six
==> Installing protobuf dependency: six
==> Pouring six-1.16.0_1.arm64_big_sur.bottle.tar.gz
Error: No such file or directory @ rb_sysopen - /Users/administrator/Library/Caches/Homebrew/downloads/b2d32282c41ba4907220501baebea0c80fcc339a9b91684245d54261c17360b0--six-1.16.0_1.arm64_big_sur.bottle.tar.gz

# æ¯”å¦‚ç°åœ¨å°±æ˜¯ æ‰¾ä¸åˆ° /Users/administrator/Library/Cachesä¸‹çš„è¿™ä¸ªidå·çš„é—®é¢˜ï¼Œä½ å¯ä»¥å…ˆæŠŠ Caches ä¸‹éƒ½æ¸…ç†ä¸€éï¼Œåœ¨é‡æ–°å®‰è£…
```

2. å…³äºgoå‡çº§

```shell
brew upgrade go
```

3. å…³äº protoc xxxæŒ‡ä»¤é”™è¯¯

```shell
$ protoc --go-grpc_out= ./search.proto 
protoc-gen-go-grpc: program not found or is not executable
Please specify a program using absolute path or make sure the program is available in your PATH system variable
--go-grpc_out: protoc-gen-go-grpc: Plugin failed with status code 1.

```

é¦–å…ˆå…ˆå®‰è£…ç¡®ä¿ ä¸€äº›æ­£ç¡®çš„æ–‡ä»¶ ï¼ˆåœ¨ä½ çš„é¡¹ç›®rootä¸‹ï¼‰

```shell
$ go get -u google.golang.org/grpc

# ä»»é€‰å…¶ä¸€å¦‚æœæœ‰é—®é¢˜
$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
$ go get -u github.com/golang/protobuf/protoc-gen-go

```

ç„¶å ç¡®ä¿ä½ çš„go env çš„bin æ‰§è¡Œæ˜¯æœ‰å…³è”çš„

```shell
$ go env 
# å…ˆçœ‹çœ‹ go path å’Œ go bin æ˜¯å¦æ­£ç¡®ï¼Œå¦‚æœä¸ï¼Œè¯·å»ä¿®æ”¹,æˆ‘è¿™é‡Œæ˜¯ zshrc ï¼Œ åŠ å…¥ä¸‹é¢çš„å†…å®¹ï¼Œç„¶åæ›´æ–°å°±å¥½å•¦ source ~/.zshrc      ,æœ€åå» go env æ£€æŸ¥ä¸€ä¸‹çœ‹çœ‹æ˜¯å¦å·²ç»é…ç½®å®Œï¼Œå¦‚æœæ˜¯é‚£ä¹ˆä¹…å®Œæˆå•¦
export GOPATH=$HOME/go
export GOBIN=$GOPATH/bin
export PATH=$PATH:$GOPATH/bin

```

4. ä¾æ®åè®® æ¥è½¬è¯‘ çš„æ—¶å€™ï¼Œå¤±è´¥çš„é—®é¢˜

ä½ éœ€è¦ç”¨è‡ªå·±çš„åŒ…ï¼Œæ¯”å¦‚ æˆ‘è‡ªå·±çš„ github.com/BM-laoli/go-gin-example/proto

```go
syntax = "proto3";

package proto;

option go_package ="github.com/BM-laoli/go-gin-example/proto";

service SearchService {
    rpc Search(SearchRequest) returns (SearchResponse) {}
}

message SearchRequest {
    string request = 1;
}

message SearchResponse {
    string response = 1;
}

```

ç¬¬äºŒï¼Œä½ åœ¨ protoc ğŸ”§, (æ‰§è¡Œçš„æ–‡ä»¶å¤¹åœ¨é¡¹ç›®çš„æ ¹ç›®å½•go-gin-exampale)

```shell
$ protoc --go_out=. --go_opt=paths=source_relative \
    --go-grpc_out=. --go-grpc_opt=paths=source_relative \
    proto/search.proto
```

è¿™ä¸ªå‘½ä»¤å®Œä¹‹åå›ç”Ÿäº§ä¸¤ä¸ª æ–‡ä»¶ï¼Œå…·ä½“è¯·çœ‹å®˜æ–¹æ–‡æ¡£ [go-rpcå®˜æ–¹æ–‡æ¡£](https://grpc.io/docs/languages/go/quickstart/)

ç¬¬ä¸‰ï¼Œä½ éœ€è¦ å®ç°å®ƒ

```go
type SearchService struct {
 pb.SearchServiceServer
}
```

# gRPC Streaming, Client and Server

> è¿™é‡Œä¸»è¦è¯´å—ï¼Œä¸‰ç§ä¸åŒçš„æ•°æ®ä¼ è¾“æ–¹å¼æ¯”ï¼Œä¸€æ–¹ç”¨æµ ä¸€æ–¹ä¸ç”¨ï¼Œæˆ–åŒæ–¹éƒ½ç”¨

1. ä¸‰ç§ä¼ è¾“æ–¹å¼

```proto
service StreamService {
// Listï¼šæœåŠ¡å™¨ç«¯æµå¼ RPC
// Recordï¼šå®¢æˆ·ç«¯æµå¼ RPC
// Routeï¼šåŒå‘æµå¼ RPC
    rpc List(StreamRequest) returns (stream StreamResponse) {};

    rpc Record(stream StreamRequest) returns (StreamResponse) {};

    rpc Route(stream StreamRequest) returns (stream StreamResponse) {};
}
```

æœ¬ç« èŠ‚ï¼Œæ²¡æœ‰è¯´æ˜å…¶ä»–è¦è¯´æ˜çš„ï¼Œå°±æ˜¯ç®€å•çš„è¯´ä¸€äº›ä¸‰ç§stream ä¼ è¾“çš„ç®€å•ä½¿ç”¨ï¼Œä»¥åŠå®ƒä»¬çš„ä½¿ç”¨åœºæ™¯

# åŸºäºCAçš„TLSè¯ä¹¦

> å‰é¢çš„set debug æ€ä¹ˆèƒ½ä¸Šç”Ÿäº§å‘¢ï¼Ÿè¿™æ˜¯ä¸å¯ä»¥çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦åŠ CA, ç”±äºå†å²é—®é¢˜ ï¼Œä»¥åŠç…é±¼å¤§ç¥çš„blog ä¸Šè¿™ç¯‡æ–‡ç« å‘å¸ƒåœ¨2018å¹´ï¼Œç°åœ¨æˆ‘å†™è¿™ç¯‡æ–‡ç« ï¼Œå·²ç»ä¸Š2023å¹´ï¼Œæˆ‘ä»¬éœ€è¦å¯¹ç…§ grpc å®˜æ–¹æ¥çœ‹, grpc å®˜æ–¹ + ç…é±¼

è¿™é‡Œæœ‰ç¯‡ [CSDN](https://blog.csdn.net/weixin_41335923/article/details/124250753)çš„ è§£è¯»ï¼Œè¿˜ç®—ä¸é”™çš„

grpc å®˜æ–¹çš„ä¸€ä¸ª ca è„šæœ¬ç”Ÿæˆå™¨ï¼Œæˆ‘ç›´æ¥æ‹¿è¿‡æ¥äº† ï¼ˆæ³¨æ„ä½ éœ€è¦cvå®ƒä»¬çš„ .conf æ–‡ä»¶ï¼Œå¹¶ä¸”ä½ è¦æœ‰ä¸€å®šçš„çŸ¥è¯†ï¼Œå¯¹ä½ TALï¼Œå¯ä»¥å‚è€ƒä¸‹é¢çš„ä¸€ç‰‡æ–‡ç« ï¼‰

[OpenSSL openssl.cnf](https://blog.csdn.net/wzfgd/article/details/109805158)

[create_ca.sh](https://github.com/grpc/grpc-go/blob/master/examples/data/x509/create.sh)

[è¿™ç¯‡æ–‡ç« æœ‰é”™è¯¯ï¼Œåœ¨å®è·µçš„æ—¶å€™ä»£ç å¯¹ä¸ä¸Šçš„ï¼Œä¹Ÿä¸çŸ¥é“å®ƒæ€ä¹ˆæ•¢å‘ï¼Œä½†æ˜¯ç†è®ºå†…å®¹å¯ä»¥çœ‹çœ‹](https://blog.csdn.net/scarificed/article/details/126184422)

grpc å®˜æ–¹ ä¾‹å­ï¼Œ[grcp-å®˜æ–¹TSLä¾‹å­](https://github.com/grpc/grpc-go/tree/master/examples/features/encryption)ã€‚é‡Œé¢çš„mTSL å°±æ˜¯äºæˆ‘ä»¬å¯¹åº”çš„å†…å®¹

# Unary and Stream interceptor æ‹¦æˆªå™¨
>
> è¿™ä¸ªä¸œè¥¿ç›¸å¯¹çš„ç®€å•ï¼Œæ²¡æœ‰ä»€ä¹ˆå‘ï¼Œè¿™é‡Œå°±ä¸å±•å¼€è¯´æ˜äº†ï¼Œè¯·ç›´æ¥å»çœ‹ å®˜æ–¹æ–‡æ¡£ï¼Œå’Œç…é±¼çš„æ–‡ç« å°±å¥½äº†
[jainyuBlog](https://eddycjy.com/posts/go/grpc/2018-10-10-interceptor/),  [go-grpc-middleware](https://github.com/grpc-ecosystem/go-grpc-middleware)

å¤šè¯´ä¸€å¥ interceptor å’Œ middleware çš„å…³ç³»ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ Nestçš„å·¥ç¨‹æ¥ä¸¾ä¾‹å­ï¼Œè¿™é‡Œæœ‰ä¸€ä¸ªæˆ‘è®¤ä¸ºè¿˜æ˜¯ä¸é”™çš„æ–‡ç«  ä¾›ä½ å‚è€ƒ [Nesté¡¹ç›®ç»“æ„ä¸­çš„å„ä¸ªéƒ¨åˆ†](https://blog.csdn.net/lxy869718069/article/details/103960790)ï¼Œå½“ç„¶æˆ‘è®¤ä¸ºè¿™ä¸æ˜¯ç»å¯¹çš„é¡ºåºï¼Œæœ‰æ—¶å€™å®ƒå–å†³ä½ çš„ è®¾è®¡çš„ï¼Œå‡è®¾ä½ çš„è®¾è®¡ä¸­  ä½ æŠŠ interceptor å’Œ middleware æ¢äº†ä¸ªä½ç½®ã€‚é‚£ä¹ˆè¿™ä¸ªæ—¶å€™åº”è¯¥ä¸ä½ è‡ªå·±çš„æœ‰å…³

# åŒæ—¶æä¾›http/https æœåŠ¡

> æ ¸å¿ƒæ­¥éª¤ï¼šåˆ¤æ–­ -> è½¬å‘ -> å“åº”ã€‚(æ³¨æ„ è¿™åªæ˜¯ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼Œå¹¶ä¸å®Œå…¨ç¬¦åˆç”Ÿäº§æ ‡å‡†)

è¿™äº†å’Œç…é±¼å¤§ç¥çš„åšå®¢æœ‰ç‚¹ç‚¹çš„åŒºåˆ«ï¼Œæˆ‘ä»¬å¹¶æ²¡æœ‰æå–ä¸€äº›å…¬å…±çš„ca å·¥å…·æ–¹æ³•ï¼Œæˆ‘ä»¬ç›´æ¥cv äº†ä¸Šä¸€ä¸ªcommit ä¸­çš„  server / client ï¼Œç„¶ååšäº†ä¸‹é¢çš„ä¿®æ”¹

```go

//  è¿™æ˜¯ä¸€ä¸ª handle è¯·æ±‚å¤„ç†å‡½æ•° å½“æœ‰httpè¯·æ±‚æ¥çš„æ—¶å€™ä¼šèµ°åˆ°è¿™é‡Œ
func GetHTTPServeMux() *http.ServeMux {
 mux := http.NewServeMux()
 mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
  w.Write([]byte("bm-laoli: go-inxxxxx"))
 })
 return mux
}

// åœ¨åŸæ¥çš„ä¸œè¥¿é‡Œé¢ï¼Œåˆ¤æ–­ä¸€ä¸‹å°±å¥½äº†

// å»æ‰ 
 // lis, err := net.Listen("tcp", ":"+PORT)
 // if err != nil {
 //  log.Fatalf("net.Listen err: %v", err)
 // }
 // server.Serve(lis)
 
//  ç¼“æˆä¸‹é¢çš„å†…å®¹ ä¸»è¦æ˜¯ç›´æ¥ç”¨http TLS ç…å¬ è¯·æ±‚ï¼Œç„¶ååˆ†åˆ«è½¬åˆ°grpc å’Œ http è¯·æ±‚ä¸Š

 http.ListenAndServeTLS(":"+PORT,
  certFile,
  keyFile,
  http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   if r.ProtoMajor == 2 && strings.Contains(r.Header.Get("Content-Type"), "application/grpc") {
    server.ServeHTTP(w, r)
   } else {
    mux.ServeHTTP(w, r)
   }

   return
  }),
 )
```

# è‡ªå®šä¹‰éªŒè¯
>
> æˆ‘ä»¬ä¸€æ­¥åˆ°ä½ç›´æ¥ ç”¨interceptor å°è£…ä¸€ä¸‹

1. éœ€è¦æå‰äº†è§£çš„çŸ¥è¯†ç‚¹

```go
type PerRPCCredentials interface {
    GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error)
    RequireTransportSecurity() bool
}

// è¿™ä¸ªæ˜¯ gRPC é»˜è®¤æä¾›ç”¨äºè‡ªå®šä¹‰è®¤è¯çš„æ¥å£ï¼Œå®ƒçš„ä½œç”¨æ˜¯å°†æ‰€éœ€çš„å®‰å…¨è®¤è¯ä¿¡æ¯æ·»åŠ åˆ°æ¯ä¸ª RPC æ–¹æ³•çš„ä¸Šä¸‹æ–‡ä¸­
// GetRequestMetadataï¼šè·å–å½“å‰è¯·æ±‚è®¤è¯æ‰€éœ€çš„å…ƒæ•°æ®ï¼ˆmetadataï¼‰
// RequireTransportSecurityï¼šæ˜¯å¦éœ€è¦åŸºäº TLS è®¤è¯è¿›è¡Œå®‰å…¨ä¼ è¾“
```

2. å›åˆ°å…·ä½“çš„æ“ä½œä¸Š æˆ‘ä»¬è¿˜æ˜¯cvä¸€ä¸‹ ä¸Šä¸€èŠ‚çš„ä»£ç ï¼Œç„¶ååšå¦‚ä¸‹çš„ä¿®æ”¹

```go
// ç¬¬ä¸€ å…ˆæ”¹é€  server

++++
const PORT = "9001"

// å®ç° PerRPCCredentials start
type Auth struct {
 AppKey    string
 AppSecret string
}

func (a *Auth) GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) {
 return map[string]string{"app_key": a.AppKey, "app_secret": a.AppSecret}, nil
}

func (a *Auth) RequireTransportSecurity() bool {
 return true
}

func (a *Auth) Check(ctx context.Context) error {
 md, ok := metadata.FromIncomingContext(ctx)
 if !ok {
  return status.Errorf(codes.Unauthenticated, "è‡ªå®šä¹‰è®¤è¯ Token å¤±è´¥")
 }

 var (
  appKey    string
  appSecret string
 )
 if value, ok := md["app_key"]; ok {
  appKey = value[0]
 }
 if value, ok := md["app_secret"]; ok {
  appSecret = value[0]
 }

 if appKey != a.GetAppKey() || appSecret != a.GetAppSecret() {
  return status.Errorf(codes.Unauthenticated, "è‡ªå®šä¹‰è®¤è¯ Token æ— æ•ˆ")
 }

 return nil
}

type SearchService struct {
 pb.SearchServiceServer
 auth Auth
}

func (a *Auth) GetAppKey() string {
 return a.AppKey
}

func (a *Auth) GetAppSecret() string {
 return a.AppSecret
}


func CustomerAuth(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface{}, err error) {

 auth := Auth{
  AppKey:    "bmlaoli",
  AppSecret: "861795660",
 }

 //  if å¦‚æœå¤´ä¸Šæœ‰æ•°æ®å°±æˆåŠŸ
 if err := auth.Check(ctx); err != nil {
  log.Println("å¤±è´¥äº†")
  return nil, err
 }

// ä¸€å®šè¦ handler å“ˆ è¦ä¸ç„¶å°±æ²¡æ³•next ä¸‹å»äº†
 resp, err2 := handler(ctx, req)
 if err2 != nil {
  return nil, err2
 }
 return resp, err
}


// å®ç° PerRPCCredentials end
++++
 opts := []grpc.ServerOption{
  grpc.Creds(c),
  grpc_middleware.WithUnaryServerChain(
   RecoveryInterceptor,
   LoggingInterceptor,
   CustomerAuth, // æŠŠè¿™ä¸ªè‡ªå®šä¹‰çš„ éªŒè¯å™¨ åŠ ä¸Šå°±å¥½äº†
  ),
 }
++++

// å¯¹äºå®¢æˆ·ç«¯ä¹Ÿæ˜¯ä¸€æ ·çš„ 
// å®ç° PerRPCCredentials start
type Auth struct {
 AppKey    string
 AppSecret string
}

func (a *Auth) GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) {
 return map[string]string{"app_key": a.AppKey, "app_secret": a.AppSecret}, nil
}

func (a *Auth) RequireTransportSecurity() bool {
 return true
}

// å®ç° PerRPCCredentials end

func main() {
  ++++
 auth := Auth{
  AppKey:    "bmlaoli",
  AppSecret: "8617956603",
 }
  ++++
//ç›´æ¥åŠ ä¸€ä¸ª WithPerRPCCredentials
 conn, err := grpc.Dial(":"+PORT, grpc.WithTransportCredentials(c), grpc.WithPerRPCCredentials(&auth))
  ++++
}

```

# gRPC Deadlines
>
> ä¸»è¦å°±æ˜¯è®¾ç½®ä¸€ä¸ª æœ€ç»ˆæ—¶é—´ï¼Œåˆ°äº†å°±ä¸è®©è¯·æ±‚æˆ–è€…ç¨‹åºè¿›è¡Œä¸‹å»äº†ï¼Œé»˜è®¤çš„grpcä¸­ è¿™ä¸ªæ—¶é—´ä¸Šæœ‰ç‚¹é•¿çš„ï¼ˆDEADLINE_EXCEEDEDï¼‰ã€‚(ç…é±¼ğŸŸçš„æ–‡ç« æœ‰ç‚¹æ—§ï¼Œä½†æ˜¯å¹¶æ²¡è¿‡æ—¶ æˆ‘ä»¬è¿˜æ˜¯ç”¨ä»–çš„æ–‡ç« æ¥åš)ï¼Œæˆ‘ä»¬ç›´æ¥çœ‹æœ€æ–°çš„ [å®˜æ–¹æ–‡æ¡£](https://grpc.io/blog/deadlines/),  ä¸€ä¸ªä¸é”™çš„åšå®¢çš„è§£æ[link]( https://www.cnblogs.com/jiujuan/p/13499915.html )ã€‚

```go
// è®¾ç½®ä¸€ä¸ªdeadline ä¸»è¦æ˜¯client 
++++

 ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(time.Duration(5*time.Second)))
 defer cancel()

 //ç›´æ¥åŠ ä¸€ä¸ª WithPerRPCCredentials
 conn, err := grpc.Dial(":"+PORT, grpc.WithTransportCredentials(c), grpc.WithPerRPCCredentials(&auth))

 if err != nil {
  log.Fatalf("grpc.Dial err: %v", err)
 }

 defer conn.Close()

 client := pb.NewSearchServiceClient(conn)
 resp, err := client.Search(ctx, &pb.SearchRequest{
  Request: "gRPC http",
 })

++++

// æ£€æŸ¥ deadline ï¼ˆclient å’Œservice éƒ½è¦æ£€æŸ¥ ï¼‰
++++Client
 if err != nil {
  statusErr, ok := status.FromError(err)
  if ok {
   if statusErr.Code() == codes.Canceled { // æ£€æŸ¥ Canceled å­—æ®µ
    log.Fatalln("client.Search err: deadline")
   }
  }

  log.Fatalf("client.Search err: %v", err)
  return
 }

 log.Printf("resp: %s", resp.GetResponse())
++++ service 
   if ctx.Err() == context.Canceled {
   return nil, status.Errorf(codes.Canceled, "SearchService.Search canceled")
  }

// åˆ¤æ–­ deadline ä¹‹åçš„åç»­åŠ¨ä½œ ï¼ˆclient å’Œ service ï¼‰è¿™é‡Œä¸å†™äº†

// è¡¥å……ä¸€æ®µ è®©service sleep çš„ä»£ç ï¼Œä»¥è¾¾åˆ°â€œtime out " ç›®çš„ 
+++++
func (s *SearchService) Search(ctx context.Context, r *pb.SearchRequest) (*pb.SearchResponse, error) {

 // ä¼‘çœ  service ä¹Ÿè¦åštime out æ£€æŸ¥ è¿™ä¸ªæ£€æŸ¥å°± çœ‹ Canceled å­—æ®µ
 for i := 0; i < 5; i++ {
  if ctx.Err() == context.Canceled {
   return nil, status.Errorf(codes.Canceled, "SearchService.Search canceled")
  }

  time.Sleep(1 * time.Second)
 }

 return &pb.SearchResponse{Response: r.GetRequest() + " Server!!!"}, nil
}

```

# åˆ†å¸ƒå¼é“¾è·¯è¿½è¸ª gRPC + Opentracing + Zipkin

> ç…é±¼çš„æ–‡æ¡£æœ‰ç‚¹ç‚¹çš„æ—§ ç‰ˆæœ¬å¤šå¤šå°‘å°‘ä¹Ÿæœ‰ç‚¹ é—®é¢˜ï¼Œå®‰è£…å®ƒçš„æ–‡æ¡£æ˜¯è¿è¡Œä¸èµ·æ¥çš„ï¼› æˆ‘ä»¬ç›´æ¥å» çœ‹ä¸‹é¢è¿™äº›å†…å®¹
<https://github.com/openzipkin/zipkin>ï¼Œ
<https://pkg.go.dev/github.com/openzipkin/zipkin-go#section-readme>
<https://pkg.go.dev/github.com/openzipkin-contrib/zipkin-go-opentracing>

çŸ¥ä¹æ–‡ç« ï¼Œæ˜é‡‘æ–‡ç« 
<https://zhuanlan.zhihu.com/p/453190067>,
<https://juejin.cn/post/7051874138877198344>

1. docker æŠŠ zipkin å¹³å°è¿è¡Œèµ·æ¥ (è¿‡äºç®€å•è¿™é‡Œä¸è¯´äº†)

2. å®‰è£…å¿…è¦çš„ä¾èµ– åˆ°æˆ‘ä»¬çš„ç¨‹åºä¸­, ä¸ zipkin å¹³å°è¿›è¡Œé›†æˆ

> é‡è¦çš„äº‹æƒ…ï¼ï¼ï¼ ä¸€å®šä¸€å®šè¦æ³¨æ„ç‰ˆæœ¬ v2ï¼ ä¸æ˜¯ v1 v1 ä½ å°±400 äº†

ä¾èµ–æ˜¯

```go
 import (
    "github.com/grpc-ecosystem/grpc-opentracing/go/otgrpc"
    "github.com/opentracing/opentracing-go"
    zipkinot "github.com/openzipkin-contrib/zipkin-go-opentracing"
    "github.com/openzipkin/zipkin-go"
    "github.com/openzipkin/zipkin-go/reporter"
    httpreport "github.com/openzipkin/zipkin-go/reporter/http"
    ++++
  )
```

ä»£ç æ˜¯

```go
// ---------------------------------server

const (
 serviceName        = "simple_zipkin_server"
 zipkinAddr         = "http://127.0.0.1:9411/api/v2/spans"
 zipkinRecorderAddr = "127.0.0.1:9001"
)

// åˆ›å»ºä¸€ä¸ªzipkinè¿½è¸ªå™¨
// url:http://localhost:9411/api/v2/spans
// serviceName:æœåŠ¡åï¼ŒEndpointæ ‡è®°
// hostPortï¼šip:portï¼ŒEndpointæ ‡è®°
func NewZipkinTracer(url, serviceName, hostPort string) (*zipkin.Tracer, reporter.Reporter, error) {

 // åˆå§‹åŒ–zipkin reporter
 // reporterå¯ä»¥æœ‰å¾ˆå¤šç§ï¼Œå¦‚ï¼šlogReporterã€httpReporterï¼Œè¿™é‡Œæˆ‘ä»¬åªä½¿ç”¨httpReporterå°†spanæŠ¥å‘Šç»™httpæœåŠ¡ï¼Œä¹Ÿå°±æ˜¯zipkinçš„httpåå°
 r := httpreport.NewReporter(url)

 //åˆ›å»ºä¸€ä¸ªendpointï¼Œç”¨æ¥æ ‡è¯†å½“å‰æœåŠ¡ï¼ŒæœåŠ¡åï¼šæœåŠ¡åœ°å€å’Œç«¯å£
 endpoint, err := zipkin.NewEndpoint(serviceName, hostPort)
 if err != nil {
  return nil, r, err
 }

 // åˆå§‹åŒ–è¿½è¸ªå™¨ ä¸»è¦ä½œç”¨æœ‰è§£æspanï¼Œè§£æä¸Šä¸‹æ–‡ç­‰
 tracer, err := zipkin.NewTracer(r, zipkin.WithLocalEndpoint(endpoint))
 if err != nil {
  return nil, r, err
 }

 return tracer, r, nil
}

// zipkin start
 tracer, r, err := NewZipkinTracer(zipkinAddr, serviceName, zipkinRecorderAddr)
 defer r.Close()
 if err != nil {
  log.Println("tracking-<", err)
  return
 }
 t := zipkinot.Wrap(tracer)
 opentracing.SetGlobalTracer(t)
 // zipkin end

 opts := []grpc.ServerOption{
  grpc.Creds(c),
  // grpc.StatsHandler(zipkingrpc.NewServerHandler(tracer)),
  grpc_middleware.WithUnaryServerChain(
   RecoveryInterceptor,
   LoggingInterceptor,
   otgrpc.OpenTracingServerInterceptor(t, otgrpc.LogPayloads()),
  ),
 }

// ---------------------------------client
 // zipkin start
 tracer, r, err := NewZipkinTracer(zipkinAddr, serviceName, zipkinRecorderAddr)
 defer r.Close()
 if err != nil {
  log.Println("tracer %d", err)
  return
 }
 t := zipkinot.Wrap(tracer)
 opentracing.SetGlobalTracer(t)
 // zipkin end

   conn, err := grpc.Dial(":"+PORT, grpc.WithTransportCredentials(c),
  grpc.WithUnaryInterceptor(
   otgrpc.OpenTracingClientInterceptor(t, otgrpc.LogPayloads()),
  ),
 )

// ---------------------------------å…¶å®ƒè¯´æ˜
// ç‰¹æ®Šè¯´æ˜ å®é™…ä¸Šæˆ‘ä»¬ä¹Ÿ å¯ä»¥ç”¨å®˜æ–¹ zipkin-go æ–‡æ¡£ä¸­æåˆ°çš„ 
 opts := []grpc.ServerOption{
  grpc.Creds(c),
  grpc.StatsHandler(zipkingrpc.NewServerHandler(tracer)),
  grpc_middleware.WithUnaryServerChain(
   RecoveryInterceptor,
   LoggingInterceptor,
  ),
 }

   conn, err := grpc.Dial(":"+PORT,
     grpc.WithTransportCredentials(c),
     grpc.WithStatsHandler(zipkingrpc.NewClientHandler(tracer)) )
```
